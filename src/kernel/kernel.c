#include "stddef.h"
#include <kernel.h>
#include <stdio.h>

#include <sbi/sbi.h>
#include <memory_mgmt.h>
#include <memory/page_allocator.h>
#include <memory/slab_allocator.h>
#include <process.h>
#include <devices/device_tree.h>
#include <devices/virtio.h>
#include <devices/pci.h>
#include <harts.h>

#include <common.h>

extern char __bss[], __bss_end[], __stack_top[], __free_ram[], __free_ram_end[], __kernel_base[], _binary___build_shell_bin_start[], _binary___build_shell_bin_size[];
extern struct file files[FILES_MAX];
extern struct process procs[PROCS_MAX];

// Currently running process

__attribute__((naked))
__attribute__((aligned(4)))
void kernel_entry(void) {
    __asm__ __volatile__(
        // Retrieve the kernel stack of the running process from sscratch
        "csrrw sp, sscratch, sp\n"
        "addi sp, sp, -4 * 31\n"
        "sw ra,  4 * 0(sp)\n"
        "sw gp,  4 * 1(sp)\n"
        "sw tp,  4 * 2(sp)\n"
        "sw t0,  4 * 3(sp)\n"
        "sw t1,  4 * 4(sp)\n"
        "sw t2,  4 * 5(sp)\n"
        "sw t3,  4 * 6(sp)\n"
        "sw t4,  4 * 7(sp)\n"
        "sw t5,  4 * 8(sp)\n"
        "sw t6,  4 * 9(sp)\n"
        "sw a0,  4 * 10(sp)\n"
        "sw a1,  4 * 11(sp)\n"
        "sw a2,  4 * 12(sp)\n"
        "sw a3,  4 * 13(sp)\n"
        "sw a4,  4 * 14(sp)\n"
        "sw a5,  4 * 15(sp)\n"
        "sw a6,  4 * 16(sp)\n"
        "sw a7,  4 * 17(sp)\n"
        "sw s0,  4 * 18(sp)\n"
        "sw s1,  4 * 19(sp)\n"
        "sw s2,  4 * 20(sp)\n"
        "sw s3,  4 * 21(sp)\n"
        "sw s4,  4 * 22(sp)\n"
        "sw s5,  4 * 23(sp)\n"
        "sw s6,  4 * 24(sp)\n"
        "sw s7,  4 * 25(sp)\n"
        "sw s8,  4 * 26(sp)\n"
        "sw s9,  4 * 27(sp)\n"
        "sw s10, 4 * 28(sp)\n"
        "sw s11, 4 * 29(sp)\n"

        // Retrieve and save the sp at the time of exception
        "csrr a0, sscratch\n"
        "sw a0, 4 * 30(sp)\n"

        // Reset the kernel stack
        "addi a0, sp, 4 * 31\n"
        "csrw sscratch, a0\n"

        "mv a0, sp\n"
        "call handle_trap\n"

        "lw ra,  4 * 0(sp)\n"
        "lw gp,  4 * 1(sp)\n"
        "lw tp,  4 * 2(sp)\n"
        "lw t0,  4 * 3(sp)\n"
        "lw t1,  4 * 4(sp)\n"
        "lw t2,  4 * 5(sp)\n"
        "lw t3,  4 * 6(sp)\n"
        "lw t4,  4 * 7(sp)\n"
        "lw t5,  4 * 8(sp)\n"
        "lw t6,  4 * 9(sp)\n"
        "lw a0,  4 * 10(sp)\n"
        "lw a1,  4 * 11(sp)\n"
        "lw a2,  4 * 12(sp)\n"
        "lw a3,  4 * 13(sp)\n"
        "lw a4,  4 * 14(sp)\n"
        "lw a5,  4 * 15(sp)\n"
        "lw a6,  4 * 16(sp)\n"
        "lw a7,  4 * 17(sp)\n"
        "lw s0,  4 * 18(sp)\n"
        "lw s1,  4 * 19(sp)\n"
        "lw s2,  4 * 20(sp)\n"
        "lw s3,  4 * 21(sp)\n"
        "lw s4,  4 * 22(sp)\n"
        "lw s5,  4 * 23(sp)\n"
        "lw s6,  4 * 24(sp)\n"
        "lw s7,  4 * 25(sp)\n"
        "lw s8,  4 * 26(sp)\n"
        "lw s9,  4 * 27(sp)\n"
        "lw s10, 4 * 28(sp)\n"
        "lw s11, 4 * 29(sp)\n"
        "lw sp,  4 * 30(sp)\n"
        "sret\n"
    );
}

void secondary_handle_trap(__attribute__((unused)) struct trap_frame *f) {
    uint32_t scause = READ_CSR(scause);
    uint32_t stval = READ_CSR(stval);
    uint32_t user_pc = READ_CSR(sepc);
    if (scause == SCAUSE_ECALL) {
        PANIC("ECALL ON SECONDARY THREAD!\n");
        user_pc += 4;
    } else {
        PANIC("unexpected trap scause=%x, stval=%x, sepc=%x\n", scause, stval, user_pc);
    }

    kprintf("[SECONDARY] trap scause=%x, stval=%x, sepc=%x\n", scause, stval, user_pc);

    WRITE_CSR(sepc, user_pc);
}

__attribute__((naked))
__attribute__((aligned(4)))
void secondary_entry(void) {
    __asm__ __volatile__(
        // Retrieve the kernel stack of the running process from sscratch
        "csrrw sp, sscratch, sp\n"
        "addi sp, sp, -4 * 31\n"
        "sw ra,  4 * 0(sp)\n"
        "sw gp,  4 * 1(sp)\n"
        "sw tp,  4 * 2(sp)\n"
        "sw t0,  4 * 3(sp)\n"
        "sw t1,  4 * 4(sp)\n"
        "sw t2,  4 * 5(sp)\n"
        "sw t3,  4 * 6(sp)\n"
        "sw t4,  4 * 7(sp)\n"
        "sw t5,  4 * 8(sp)\n"
        "sw t6,  4 * 9(sp)\n"
        "sw a0,  4 * 10(sp)\n"
        "sw a1,  4 * 11(sp)\n"
        "sw a2,  4 * 12(sp)\n"
        "sw a3,  4 * 13(sp)\n"
        "sw a4,  4 * 14(sp)\n"
        "sw a5,  4 * 15(sp)\n"
        "sw a6,  4 * 16(sp)\n"
        "sw a7,  4 * 17(sp)\n"
        "sw s0,  4 * 18(sp)\n"
        "sw s1,  4 * 19(sp)\n"
        "sw s2,  4 * 20(sp)\n"
        "sw s3,  4 * 21(sp)\n"
        "sw s4,  4 * 22(sp)\n"
        "sw s5,  4 * 23(sp)\n"
        "sw s6,  4 * 24(sp)\n"
        "sw s7,  4 * 25(sp)\n"
        "sw s8,  4 * 26(sp)\n"
        "sw s9,  4 * 27(sp)\n"
        "sw s10, 4 * 28(sp)\n"
        "sw s11, 4 * 29(sp)\n"

        // Retrieve and save the sp at the time of exception
        "csrr a0, sscratch\n"
        "sw a0, 4 * 30(sp)\n"

        // Reset the kernel stack
        "addi a0, sp, 4 * 31\n"
        "csrw sscratch, a0\n"

        "mv a0, sp\n"
        "call secondary_handle_trap\n"

        "lw ra,  4 * 0(sp)\n"
        "lw gp,  4 * 1(sp)\n"
        "lw tp,  4 * 2(sp)\n"
        "lw t0,  4 * 3(sp)\n"
        "lw t1,  4 * 4(sp)\n"
        "lw t2,  4 * 5(sp)\n"
        "lw t3,  4 * 6(sp)\n"
        "lw t4,  4 * 7(sp)\n"
        "lw t5,  4 * 8(sp)\n"
        "lw t6,  4 * 9(sp)\n"
        "lw a0,  4 * 10(sp)\n"
        "lw a1,  4 * 11(sp)\n"
        "lw a2,  4 * 12(sp)\n"
        "lw a3,  4 * 13(sp)\n"
        "lw a4,  4 * 14(sp)\n"
        "lw a5,  4 * 15(sp)\n"
        "lw a6,  4 * 16(sp)\n"
        "lw a7,  4 * 17(sp)\n"
        "lw s0,  4 * 18(sp)\n"
        "lw s1,  4 * 19(sp)\n"
        "lw s2,  4 * 20(sp)\n"
        "lw s3,  4 * 21(sp)\n"
        "lw s4,  4 * 22(sp)\n"
        "lw s5,  4 * 23(sp)\n"
        "lw s6,  4 * 24(sp)\n"
        "lw s7,  4 * 25(sp)\n"
        "lw s8,  4 * 26(sp)\n"
        "lw s9,  4 * 27(sp)\n"
        "lw s10, 4 * 28(sp)\n"
        "lw s11, 4 * 29(sp)\n"
        "lw sp,  4 * 30(sp)\n"
        "sret\n"
    );
}

uint32_t CLOCK_FREQ = 10000000;
uint32_t num_harts;
bool kernel_verbose = false;
volatile bool is_shutting_down = false;

void kernel_shutdown(uint32_t hartid) {
    kprintf("[SHUTDOWN] Shutting down from Hart %d. Waiting for all other Harts to stop.\n", hartid);
    is_shutting_down = true;

    uint32_t still_running = 1;
    while (still_running) {
        still_running = 0;

        for (uint32_t hid = 0; hid < num_harts; hid++) {
            if (hid == hartid) continue;
            enum SBI_HSM_STATE status = hart_get_status(hid);
            if (status != SBI_HSM_STATE_STOPPED) {
                kprintf("[SHUTDOWN] Hart %d is still running/suspended (%d)...\n", hid, status);
                still_running |= 0x1 << hid;
            }
        }
        
        if (still_running) {
            sbiret value = sbi_call(still_running, 0, 0, 0, 0, 0, SBI_IPI_FN_SEND_IPI, SBI_EXT_IPI);
            // kprintf("[SHUTDOWN] sbi_send_ipi(0x%x)\tvalue=0x%x\n\terror=%d\n", still_running, value.value, value.error);
            if (value.error)
                PANIC("OOPS: %d!\n", value.error);

            uint32_t future = READ_CSR(time) + (CLOCK_FREQ / 10);
            sbi_call(future, 0, 0, 0, 0, 0, SBI_TIME_FN_SET_TIMER, SBI_EXT_TIME);
            // kprintf("[SHUTDOWN] Sleeping for 0.1s...\n");

            WAIT_FOR_INTERRUPT();
        }
    }
    kprintf("[SHUTDOWN] All other cores are shut down.\n");

    kprintf("[SHUTDOWN] Calling system shutdown.\n");
    sbiret value = sbi_call(SBI_SRST_TYPE_SHUTDOWN, SBI_SRST_REASON_NONE, 0, 0, 0, 0, 0, SBI_EXT_SRST);
    PANIC("system_reset:\n\tvalue=0x%x\n\terror=%d\n", value.value, value.error);
}

void secondary_main(uint32_t hartid) {
    WRITE_CSR(stvec, (uint32_t) secondary_entry);
    heart_locals[hartid].hartid = hartid;
    __asm__ __volatile__(
        "mv gp, %[hartid]\n"
        "mv tp, %[procid]"
        : // Output
        : [hartid] "r" (heart_locals + hartid), // Input
          [procid] "r" (&heart_locals[hartid].current_proc)
        : "gp", "tp" // Clobbers
    );

    kprintf("[SECONDARY] Hello from hart #%d!\n", get_hart_local()->hartid);

    sbiret value;
    while (!is_shutting_down) {
        uint32_t time = READ_CSR(time);
        kprintf("[SECONDARY] CPU uptime: %d ticks. (%d.%ds?)\n", time, time / CLOCK_FREQ, (time % CLOCK_FREQ) / (CLOCK_FREQ / 1000));
        uint32_t future = time + (CLOCK_FREQ * 10);
        sbi_call(future, 0, 0, 0, 0, 0, SBI_TIME_FN_SET_TIMER, SBI_EXT_TIME);
        WAIT_FOR_INTERRUPT();
    }

    kprintf("[SECONDARY] System is shutting down, stopping Hart #%d.\n", hartid);
    value = sbi_call(0, 0, 0, 0, 0, 0, SBI_HSM_FN_HART_STOP, SBI_EXT_HSM);
    kprintf("[SECONDARY] sbi_hart_stop() value=%d\terror=%d\n", value.value, value.error);
}

struct pci_header {
    uint16_t vendor_id, device_id, command, status;
    uint8_t revision_id, prog_if, subclass, class_code,
        cache_line_size, latency_timer, header_type, bist;
} __attribute__((packed));

struct bar_packed {
            bool is_io_space : 1;
            uint8_t type : 2;
            bool prefetchable : 1;
            uint32_t base_address: 28;
        };

struct bar {
    union {
        volatile uint32_t raw;
        volatile struct bar_packed packed;
    };
} __attribute__((packed));

struct pci_type0_header {
    struct pci_header pci_header;
    struct bar bars[6];
    uint32_t cardbus_cis_pointer;
    uint16_t subsystem_vendor_id, subsystem_id;
    uint32_t expansion_rom_base_address;
    uint8_t capabilities_pointer;
    uint16_t reserved; uint8_t reserved2;
    uint32_t reserved3;
    uint8_t interrupt_line, interrupt_pin, min_grant, max_latency;
} __attribute__((packed));

void print_pci_bar(struct pci_type0_header *type0, char num) {
    struct bar *bar = &type0->bars[num];
    // TODO: if ((type0->pci_header.command & 0x02) == 0x02)
    //           PANIC("<gotta disable>\n");

    uint32_t orig = bar->raw;
    bar->raw = 0xFFFFFFFF;
    uint32_t width = ((~(bar->raw & 0xFFFFFFF0)) + 1);
    bar->raw = orig;

    if (width == 0) return;

    printf("\t\tBAR %d [0x%p] (Raw: 0x%x)\t", num, bar, bar->raw);

    uint32_t value = bar->raw;
    struct bar_packed *barp = (struct bar_packed*)&value;

    if (barp->is_io_space)
        printf("\tIO-space\t", &bar);
    else
        printf("\tMemory-space\t", &bar);
    
    printf(barp->prefetchable ? "Prefetchable\t" : "");

    switch (barp->type) {
        case 0x0: printf("32-bit\t"); break;
        case 0x2: printf("64-bit\t"); break;
        case 0x3: PANIC("RESERVED!"); break;
    }

    printf("Base: [0x%x]\t(Raw: 0x%x)\n", bar->raw & 0xFFFFFFF0, value);

    // uint32_t save = bar.raw;
    if (width >= 1024 * 1024)
        printf("\t\t\tSize: %dMiB\n", width >> 20);
    else if (width >= 1024)
        printf("\t\t\tSize: %dKiB\n", width >> 10);
    else
        printf("\t\t\tSize: %dB\n", width);
    // printf("\n\n%x\n\n", width);
    
    // *(uint32_t *)0x10000000 = 0xa0a0a0a0;
    
    // type0->bar0.raw = (uint32_t)pages;
    // printf("\nASDF (0x%p): 0x%x\n", &type0->bar0.raw, value & 0xFFFFFFF0);
    // printf(
    //    "\t\t     BAR0: 0x%s\t ...\n"
    //    "\t\tSubsys ID: 0x%x\t Sub. Vend: 0x%x\n", type0->bar0.prefetchable ? "Prefetchable" : "", type0->subsystem_id, type0->subsystem_vendor_id);
}

#define PORTS_OFF           0x400
#define PORTS_START         0x3C0

#define	VGA_AC_INDEX        0x3C0
#define VGA_AC_WRITE        0x3C0
#define VGA_AC_READ         0x3C1
#define VGA_MISC_WRITE      0x3C2
#define VGA_SEQ_INDEX       0x3C4
#define VGA_SEQ_DATA        0x3C5
#define VGA_DAC_READ_INDEX  0x3C7
#define VGA_DAC_WRITE_INDEX 0x3C8
#define VGA_DAC_DATA        0x3C9
#define VGA_MISC_READ       0x3CC
#define VGA_GC_INDEX        0x3CE
#define VGA_GC_DATA         0x3CF
/*                          COLOR emulation     MONO emulation */
#define VGA_CRTC_INDEX      0x3D4               /* 0x3B4 */
#define VGA_CRTC_DATA       0x3D5               /* 0x3B5 */
#define VGA_INSTAT_READ     0x3DA

#define VGA_NUM_SEQ_REGS    5
#define VGA_NUM_CRTC_REGS   25
#define VGA_NUM_GC_REGS     9
#define VGA_NUM_AC_REGS     21
#define VGA_NUM_REGS        (1 + VGA_NUM_SEQ_REGS + VGA_NUM_CRTC_REGS + VGA_NUM_GC_REGS + VGA_NUM_AC_REGS)

uint8_t g_320x200x4[] =
{
/* MISC */
	0x63,
/* SEQ */
	0x03, 0x09, 0x03, 0x00, 0x02,
/* CRTC */
	0x2D, 0x27, 0x28, 0x90, 0x2B, 0x80, 0xBF, 0x1F,
	0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x9C, 0x0E, 0x8F, 0x14, 0x00, 0x96, 0xB9, 0xA3,
	0xFF,
/* GC */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x02, 0x00,
	0xFF,
/* AC */
	0x00, 0x13, 0x15, 0x17, 0x02, 0x04, 0x06, 0x07,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
	0x01, 0x00, 0x03, 0x00, 0x00
};

uint8_t g_80x25_text[] =
{
/* MISC */
	0x67,
/* SEQ */
	0x03, 0x00, 0x03, 0x00, 0x02,
/* CRTC */
	0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F,
	0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x50,
	0x9C, 0x0E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3,
	0xFF,
/* GC */
	0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00,
	0xFF,
/* AC */
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
	0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
	0x0C, 0x00, 0x0F, 0x08, 0x00
};

uint8_t inp(paddr_t port_base, paddr_t port) {
    return *((uint8_t*)(port_base + port - PORTS_START));
}

void outp(paddr_t port_base, paddr_t port, uint8_t value) {
    *((uint8_t*)(port_base + port - PORTS_START)) = value;
}

void write_regs(paddr_t port_base, uint8_t *regs) {
    unsigned i;

    // Write MISC register
    outp(port_base, VGA_MISC_WRITE, *regs);
    regs++;

    // Write SEQUENCER regs
    for (i = 0; i < VGA_NUM_SEQ_REGS; i++) {
        outp(port_base, VGA_SEQ_INDEX, i);
        outp(port_base, VGA_SEQ_DATA, *regs++);
    }

    // Unlock CRTC registers
    outp(port_base, VGA_CRTC_INDEX, 0x03);
    outp(port_base, VGA_CRTC_DATA, inp(port_base, VGA_CRTC_DATA) | 0x80);
    outp(port_base, VGA_CRTC_INDEX, 0x11);
    outp(port_base, VGA_CRTC_DATA, inp(port_base, VGA_CRTC_DATA) & ~0x80);
    regs[0x03] |= 0x80;
    regs[0x11] &= ~0x80;

    // Write CRTC regs
    for (i = 0; i < VGA_NUM_CRTC_REGS; i++) {
        outp(port_base, VGA_CRTC_INDEX, i);
        outp(port_base, VGA_CRTC_DATA, *regs++);
    }

    // Write graphics controller regs
    for (i = 0; i < VGA_NUM_GC_REGS; i++) {
        outp(port_base, VGA_GC_INDEX, i);
        outp(port_base, VGA_GC_DATA, *regs++);
    }

    // Write attribute controller regs
    for (i = 0; i < VGA_NUM_AC_REGS; i++) {
        (void)inp(port_base, VGA_INSTAT_READ);
        outp(port_base, VGA_AC_INDEX, i);
        outp(port_base, VGA_AC_WRITE, *regs++);
    }

    // Lock 16-color palette and unblank display
    (void)inp(port_base, VGA_INSTAT_READ);
    outp(port_base, VGA_AC_INDEX, 0x20);
}

static unsigned get_fb_seg(paddr_t ports_base)
{
	unsigned seg;

	outp(ports_base, VGA_GC_INDEX, 6);
	seg = inp(ports_base, VGA_GC_DATA);
	seg >>= 2;
	seg &= 3;
	switch(seg)
	{
	case 0:
	case 1:
		seg = 0xA000;
		break;
	case 2:
		seg = 0xB000;
		break;
	case 3:
		seg = 0xB800;
		break;
	}
	return seg;
}

static uint8_t g_8x8_font[2048] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x7E, 0x81, 0xA5, 0x81, 0xBD, 0x99, 0x81, 0x7E,
	0x7E, 0xFF, 0xDB, 0xFF, 0xC3, 0xE7, 0xFF, 0x7E,
	0x6C, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00,
	0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00,
	0x38, 0x7C, 0x38, 0xFE, 0xFE, 0x92, 0x10, 0x7C,
	0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x7C,
	0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00,
	0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF,
	0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00,
	0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF,
	0x0F, 0x07, 0x0F, 0x7D, 0xCC, 0xCC, 0xCC, 0x78,
	0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18,
	0x3F, 0x33, 0x3F, 0x30, 0x30, 0x70, 0xF0, 0xE0,
	0x7F, 0x63, 0x7F, 0x63, 0x63, 0x67, 0xE6, 0xC0,
	0x99, 0x5A, 0x3C, 0xE7, 0xE7, 0x3C, 0x5A, 0x99,
	0x80, 0xE0, 0xF8, 0xFE, 0xF8, 0xE0, 0x80, 0x00,
	0x02, 0x0E, 0x3E, 0xFE, 0x3E, 0x0E, 0x02, 0x00,
	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x7E, 0x3C, 0x18, 
	0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00, 
	0x7F, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x00, 
	0x3E, 0x63, 0x38, 0x6C, 0x6C, 0x38, 0x86, 0xFC, 
	0x00, 0x00, 0x00, 0x00, 0x7E, 0x7E, 0x7E, 0x00, 
	0x18, 0x3C, 0x7E, 0x18, 0x7E, 0x3C, 0x18, 0xFF,
	0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00,
	0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00,
	0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 
	0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 
	0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 
	0x00, 0x24, 0x66, 0xFF, 0x66, 0x24, 0x00, 0x00, 
	0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x00, 0x00, 
	0x00, 0xFF, 0xFF, 0x7E, 0x3C, 0x18, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00,
	0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 
	0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00, 
	0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
	0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
	0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00, 
	0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
	0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 
	0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
	0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
	0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
	0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00, 
	0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xFC, 0x00, 
	0x78, 0xCC, 0x0C, 0x38, 0x60, 0xCC, 0xFC, 0x00, 
	0x78, 0xCC, 0x0C, 0x38, 0x0C, 0xCC, 0x78, 0x00, 
	0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x1E, 0x00, 
	0xFC, 0xC0, 0xF8, 0x0C, 0x0C, 0xCC, 0x78, 0x00, 
	0x38, 0x60, 0xC0, 0xF8, 0xCC, 0xCC, 0x78, 0x00,
	0xFC, 0xCC, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
	0x78, 0xCC, 0xCC, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x78, 0xCC, 0xCC, 0x7C, 0x0C, 0x18, 0x70, 0x00, 
	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00, 
	0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30, 
	0x18, 0x30, 0x60, 0xC0, 0x60, 0x30, 0x18, 0x00, 
	0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00, 
	0x60, 0x30, 0x18, 0x0C, 0x18, 0x30, 0x60, 0x00,
	0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00, 
	0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 
	0x30, 0x78, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0x00, 
	0xFC, 0x66, 0x66, 0x7C, 0x66, 0x66, 0xFC, 0x00, 
	0x3C, 0x66, 0xC0, 0xC0, 0xC0, 0x66, 0x3C, 0x00, 
	0xF8, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 
	0xFE, 0x62, 0x68, 0x78, 0x68, 0x62, 0xFE, 0x00, 
	0xFE, 0x62, 0x68, 0x78, 0x68, 0x60, 0xF0, 0x00,
	0x3C, 0x66, 0xC0, 0xC0, 0xCE, 0x66, 0x3A, 0x00, 
	0xCC, 0xCC, 0xCC, 0xFC, 0xCC, 0xCC, 0xCC, 0x00, 
	0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x1E, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 0x00, 
	0xE6, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0xE6, 0x00, 
	0xF0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 
	0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
	0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00, 
	0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 
	0xFC, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00, 
	0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0x7C, 0x0E, 0x00, 
	0xFC, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0xE6, 0x00,
	0x7C, 0xC6, 0xE0, 0x78, 0x0E, 0xC6, 0x7C, 0x00, 
	0xFC, 0xB4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xFC, 0x00, 
	0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00,
	0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00, 
	0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00, 
	0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x30, 0x78, 0x00,
	0xFE, 0xC6, 0x8C, 0x18, 0x32, 0x66, 0xFE, 0x00,
	0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
	0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
	0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00, 
	0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 
	0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
	0xE0, 0x60, 0x60, 0x7C, 0x66, 0x66, 0xDC, 0x00, 
	0x00, 0x00, 0x78, 0xCC, 0xC0, 0xCC, 0x78, 0x00,
	0x1C, 0x0C, 0x0C, 0x7C, 0xCC, 0xCC, 0x76, 0x00,
	0x00, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 
	0x38, 0x6C, 0x64, 0xF0, 0x60, 0x60, 0xF0, 0x00, 
	0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 
	0xE0, 0x60, 0x6C, 0x76, 0x66, 0x66, 0xE6, 0x00, 
	0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0xCC, 0xCC, 0x78, 
	0xE0, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0xE6, 0x00,
	0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x00, 0x00, 0xCC, 0xFE, 0xFE, 0xD6, 0xD6, 0x00, 
	0x00, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0xCC, 0x00, 
	0x00, 0x00, 0x78, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 
	0x00, 0x00, 0xDC, 0x66, 0x66, 0x7C, 0x60, 0xF0, 
	0x00, 0x00, 0x76, 0xCC, 0xCC, 0x7C, 0x0C, 0x1E, 
	0x00, 0x00, 0xDC, 0x76, 0x62, 0x60, 0xF0, 0x00, 
	0x00, 0x00, 0x7C, 0xC0, 0x70, 0x1C, 0xF8, 0x00,
	0x10, 0x30, 0xFC, 0x30, 0x30, 0x34, 0x18, 0x00, 
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x78, 0x30, 0x00, 
	0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00, 
	0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00, 
	0x00, 0x00, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8, 
	0x00, 0x00, 0xFC, 0x98, 0x30, 0x64, 0xFC, 0x00,
	0x1C, 0x30, 0x30, 0xE0, 0x30, 0x30, 0x1C, 0x00, 
	0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 
	0xE0, 0x30, 0x30, 0x1C, 0x30, 0x30, 0xE0, 0x00, 
	0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0x00,
	0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x0C, 0x06, 0x7C, 
	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00,
	0x1C, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 
	0x7E, 0x81, 0x3C, 0x06, 0x3E, 0x66, 0x3B, 0x00,
	0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
	0xE0, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00, 
	0x30, 0x30, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x00, 0x00, 0x7C, 0xC6, 0xC0, 0x78, 0x0C, 0x38,
	0x7E, 0x81, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00,
	0xCC, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00,
	0xE0, 0x00, 0x78, 0xCC, 0xFC, 0xC0, 0x78, 0x00, 
	0xCC, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x7C, 0x82, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00, 
	0xE0, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0xC6, 0x10, 0x7C, 0xC6, 0xFE, 0xC6, 0xC6, 0x00, 
	0x30, 0x30, 0x00, 0x78, 0xCC, 0xFC, 0xCC, 0x00, 
	0x1C, 0x00, 0xFC, 0x60, 0x78, 0x60, 0xFC, 0x00,
	0x00, 0x00, 0x7F, 0x0C, 0x7F, 0xCC, 0x7F, 0x00,
	0x3E, 0x6C, 0xCC, 0xFE, 0xCC, 0xCC, 0xCE, 0x00, 
	0x78, 0x84, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x00, 0xCC, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x00, 0xE0, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x78, 0x84, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
	0x00, 0xE0, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
	0x00, 0xCC, 0x00, 0xCC, 0xCC, 0x7C, 0x0C, 0xF8,
	0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00, 
	0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 
	0x18, 0x18, 0x7E, 0xC0, 0xC0, 0x7E, 0x18, 0x18, 
	0x38, 0x6C, 0x64, 0xF0, 0x60, 0xE6, 0xFC, 0x00, 
	0xCC, 0xCC, 0x78, 0x30, 0xFC, 0x30, 0xFC, 0x30, 
	0xF8, 0xCC, 0xCC, 0xFA, 0xC6, 0xCF, 0xC6, 0xC3, 
	0x0E, 0x1B, 0x18, 0x3C, 0x18, 0x18, 0xD8, 0x70, 
	0x1C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0x76, 0x00,
	0x38, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00, 
	0x00, 0x1C, 0x00, 0x78, 0xCC, 0xCC, 0x78, 0x00, 
	0x00, 0x1C, 0x00, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 
	0x00, 0xF8, 0x00, 0xB8, 0xCC, 0xCC, 0xCC, 0x00, 
	0xFC, 0x00, 0xCC, 0xEC, 0xFC, 0xDC, 0xCC, 0x00, 
	0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 
	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00,
	0x18, 0x00, 0x18, 0x18, 0x30, 0x66, 0x3C, 0x00, 
	0x00, 0x00, 0x00, 0xFC, 0xC0, 0xC0, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xFC, 0x0C, 0x0C, 0x00, 0x00, 
	0xC6, 0xCC, 0xD8, 0x36, 0x6B, 0xC2, 0x84, 0x0F, 
	0xC3, 0xC6, 0xCC, 0xDB, 0x37, 0x6D, 0xCF, 0x03,
	0x18, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x18, 0x00, 
	0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00,
	0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00, 
	0x22, 0x88, 0x22, 0x88, 0x22, 0x88, 0x22, 0x88,
	0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 
	0xDB, 0xF6, 0xDB, 0x6F, 0xDB, 0x7E, 0xD7, 0xED, 
	0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18,
	0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36,
	0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 
	0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 
	0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
	0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 
	0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00,
	0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 
	0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 
	0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 
	0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 
	0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 
	0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 
	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00,
	0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 
	0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 
	0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18, 
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 
	0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 
	0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 
	0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36,
	0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 
	0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 
	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
	0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x76, 0xDC, 0xC8, 0xDC, 0x76, 0x00,
	0x00, 0x78, 0xCC, 0xF8, 0xCC, 0xF8, 0xC0, 0xC0,
	0x00, 0xFC, 0xCC, 0xC0, 0xC0, 0xC0, 0xC0, 0x00,
	0x00, 0x00, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x00,
	0xFC, 0xCC, 0x60, 0x30, 0x60, 0xCC, 0xFC, 0x00,
	0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0x70, 0x00,
	0x00, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0xC0,
	0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x00,
	0xFC, 0x30, 0x78, 0xCC, 0xCC, 0x78, 0x30, 0xFC,
	0x38, 0x6C, 0xC6, 0xFE, 0xC6, 0x6C, 0x38, 0x00,
	0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x6C, 0xEE, 0x00,
	0x1C, 0x30, 0x18, 0x7C, 0xCC, 0xCC, 0x78, 0x00,
	0x00, 0x00, 0x7E, 0xDB, 0xDB, 0x7E, 0x00, 0x00,
	0x06, 0x0C, 0x7E, 0xDB, 0xDB, 0x7E, 0x60, 0xC0,
	0x38, 0x60, 0xC0, 0xF8, 0xC0, 0x60, 0x38, 0x00,
	0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x00,
	0x00, 0x7E, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00,
	0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00,
	0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0xFC, 0x00,
	0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0xFC, 0x00,
	0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0x70,
	0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00,
	0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00,
	0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00,
	0x0F, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x3C, 0x1C,
	0x58, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00,
	0x70, 0x98, 0x30, 0x60, 0xF8, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x3C, 0x3C, 0x3C, 0x3C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static void set_plane(paddr_t ports_base, unsigned p)
{
	unsigned char pmask;

	p &= 3;
	pmask = 1 << p;
/* set read plane */
	outp(ports_base, VGA_GC_INDEX, 4);
	outp(ports_base, VGA_GC_DATA, p);
/* set write plane */
	outp(ports_base, VGA_SEQ_INDEX, 2);
	outp(ports_base, VGA_SEQ_DATA, pmask);
}

static void vmemwr(paddr_t buffer_base, paddr_t ports_base, unsigned dst_off, unsigned char *src, unsigned count)
{
    memcpy((char *)(buffer_base + (get_fb_seg(ports_base)) * 16 + (dst_off)), src, count);
}

static void write_font(paddr_t buffer_base, paddr_t ports_base, unsigned char *buf, unsigned font_height)
{
	unsigned char seq2, seq4, gc4, gc5, gc6;
	unsigned i;

    /* save registers
       set_plane() modifies GC 4 and SEQ 2, so save them as well */
	outp(ports_base, VGA_SEQ_INDEX, 2);
	seq2 = inp(ports_base, VGA_SEQ_DATA);

	outp(ports_base, VGA_SEQ_INDEX, 4);
	seq4 = inp(ports_base, VGA_SEQ_DATA);
    /* turn off even-odd addressing (set flat addressing)
    assume: chain-4 addressing already off */
	outp(ports_base, VGA_SEQ_DATA, seq4 | 0x04);

	outp(ports_base, VGA_GC_INDEX, 4);
	gc4 = inp(ports_base, VGA_GC_DATA);

	outp(ports_base, VGA_GC_INDEX, 5);
	gc5 = inp(ports_base, VGA_GC_DATA);
    /* turn off even-odd addressing */
	outp(ports_base, VGA_GC_DATA, gc5 & ~0x10);

	outp(ports_base, VGA_GC_INDEX, 6);
	gc6 = inp(ports_base, VGA_GC_DATA);
    /* turn off even-odd addressing */
	outp(ports_base, VGA_GC_DATA, gc6 & ~0x02);
    /* write font to plane P4 */
	set_plane(ports_base, 2);
    /* write font 0 */
	for(i = 0; i < 256; i++)
	{
		vmemwr(buffer_base, ports_base, 0 + i * 32, buf, font_height);
		buf += font_height;
	}

    /* restore registers */
	outp(ports_base, VGA_SEQ_INDEX, 2);
	outp(ports_base, VGA_SEQ_DATA, seq2);
	outp(ports_base, VGA_SEQ_INDEX, 4);
	outp(ports_base, VGA_SEQ_DATA, seq4);
	outp(ports_base, VGA_GC_INDEX, 4);
	outp(ports_base, VGA_GC_DATA, gc4);
	outp(ports_base, VGA_GC_INDEX, 5);
	outp(ports_base, VGA_GC_DATA, gc5);
	outp(ports_base, VGA_GC_INDEX, 6);
	outp(ports_base, VGA_GC_DATA, gc6);
}

#define PLANE_SIZE 0x10000

void set_text_mode(paddr_t fb_base, paddr_t regs_base) {
    write_regs(regs_base + PORTS_OFF, g_320x200x4);
    // write_font(fb_base, regs_base + PORTS_OFF, g_8x8_font, 8);
    // write_font(g_8x8_font, 8);
    // unsigned segment = get_fb_seg(regs_base + PORTS_OFF);
    // Set attributes white-on-black on whole screen
    printf("Framebuffer is 0x%p-0x%p\n", fb_base, fb_base + 0x1000000);
    for (uint32_t i = 0; i < 0x2000000; i++) {
        *(((uint8_t *)fb_base) + i) = 0xff;
        if (i % (1024 * 1024) == 0)
            printf("Set framebuffer memory at 0x%p\n", fb_base + i * 2);
    }

    // for(unsigned i = 0; i < 80 * 25; i++) {
    //     *(unsigned char *)(16uL * 0xB800 + (i * 2)) = 'X';
    //     *(unsigned char *)(16uL * 0xB800 + (i * 2 + 1)) = 7;
    // }
}

void probe_pci_device(paddr_t base, uint8_t bus, uint8_t slot, uint8_t func, uint8_t offset) {
    paddr_t address = base | ((uint32_t)bus << 20) | ((uint32_t)slot << 15) | ((uint32_t)func << 12) | (offset & 0xfc);
    struct pci_header *device_header = (struct pci_header*)address;
    if (device_header->device_id != 0xffff) {
        printf("Slot #%d@0x%p:"
                 "\tDevice ID: 0x%x\tVendor ID: 0x%x\n"
               "\t\t   Status: %d  \t  Command: %d\n"
               "\t\t    Class: 0x%x\t Subclass: 0x%x\t  Prog IF: %d  \t    Revision ID: %d\n"
               "\t\t     BIST: %d  \t Header T: %d  \tLatency T: %d  \tCache Line Size: %d\n",
               slot, address,
               device_header->device_id, device_header->vendor_id, device_header->status, device_header->command, device_header->class_code, device_header->subclass, device_header->prog_if, device_header->revision_id,
               device_header->bist, device_header->header_type, device_header->latency_timer, device_header->cache_line_size);
        if (device_header->header_type == 0x0) {
            struct pci_type0_header *type0 = (struct pci_type0_header*)device_header;

            for (char bar = 0; bar < 6; bar++)
                print_pci_bar(type0, bar);

            
            // if ((type0->pci_header.status & 0x10) == 0x10)
            //     printf("\t\tCapabilities Pointer: 0x%x\n", (type0->capabilities_pointer & (~0x3)));
    

            if (bus == 0 && slot == 0) {
                uint16_t old_command = device_header->command;
                printf("\n\nEnabling bus: %x -> %x\n\n", old_command, old_command | 0x03);
                device_header->command = device_header->command | 0x03;
            }

            if (bus == 0 && slot == 1 && func == 0) {
                // paddr_t VGA_BUFFER = 0x40004000;
                paddr_t VGA_BUFFER = 0x40004000;
                printf("\n\nMapping VGA framebuffer to memory at 0x%p\n", VGA_BUFFER);
                device_header->command = device_header->command | 0x03;
                type0->bars[0].raw = (VGA_BUFFER & 0xFFFFFF00) | 0x08;
                // print_pci_bar(type0, 0);
                // uint32_t value = *((uint32_t*)(VGA_BUFFER));
                // printf("VGA_BUFFER VALUE: 0x%x\n", value);
                

                paddr_t VGA_REGS = 0x40000000;
                printf("\n\nMapping VGA registers to memory at 0x%p\n", VGA_REGS);
                type0->bars[2].raw = VGA_REGS;
                // print_pci_bar(type0, 2);
                uint32_t value = *((uint32_t*)(VGA_REGS + 0x0604));
                printf("REGISTER VALUE: 0x%x\n", value);

                set_text_mode(VGA_BUFFER, VGA_REGS);

                // *((uint32_t*)(VGA_BUFFER)) = 'f';
                // *((uint32_t*)(buffer + 0x0604)) = 0x0;
                // value = *((uint32_t*)(buffer + 0x0604));
                // printf("VALUE: 0x%x\n", value);
                // bar.raw = (uint32_t)0x10000000;
                // printf("Base address: 0x%x\n", bar.base_address & 0xFFFFFFF0);

                printf("\n\n");
            }
        }
        putchar('\n');
    }
}

void probe_pci(paddr_t base) {
    for (uint8_t slot = 0; true; slot++) {
        probe_pci_device(base, 0, slot, 0, 0);
        if (slot == 0xff) break;
    }
    // PANIC("done");
    while(true){}
}

void secondary_boot();
void kernel_main(uint32_t hartid, const fdt_header *fdt) {
    memset(__bss, 0, (size_t) __bss_end - (size_t)__bss);
    WRITE_CSR(stvec, (uint32_t) kernel_entry);
    heart_locals[hartid].hartid = hartid;
    __asm__ __volatile__(
        "mv gp, %[hartid]\n"
        "mv tp, %[procid]"
        : // Output
        : [hartid] "r" (heart_locals + hartid), // Input
          [procid] "r" (&heart_locals[hartid].current_proc)
        : "gp", "tp" // Clobbers
    );


    printf("\n\n");
    printf("\033[1;93m ______     ______     __         ______     __   __     ______     __       \n");
    printf("/\\  ___\\   /\\  __ \\   /\\ \\       /\\  __ \\   /\\ \"-.\\ \\   /\\  ___\\   /\\ \\      \n");
    printf("\\ \\ \\____  \\ \\ \\/\\ \\  \\ \\ \\____  \\ \\ \\/\\ \\  \\ \\ \\-.  \\  \\ \\  __\\   \\ \\ \\____ \n");
    printf(" \\ \\_____\\  \\ \\_____\\  \\ \\_____\\  \\ \\_____\\  \\ \\_\\\\\"\\_\\  \\ \\_____\\  \\ \\_____\\\n");
    printf("  \\/_____/   \\/_____/   \\/_____/   \\/_____/   \\/_/ \\/_/   \\/_____/   \\/_____/\033[0m\n\n");

#ifdef TESTS
    slab_test_suite();
#else
    // inspect_device_tree(fdt);
    
    // char *str = "Hello, World!\n";
    // for (int i = 0; str[i] != '\0'; ++i) {
    //     *(volatile char*)0x10000000 = str[i];
    // }
    
    // probe_virtio_device(0x10001000);
    // probe_virtio_device(0x10002000);
    // probe_virtio_device(0x10003000);
    // probe_virtio_device(0x10004000);
    // probe_virtio_device(0x10005000);
    // probe_virtio_device(0x10006000);
    // probe_virtio_device(0x10007000);
    // probe_virtio_device(0x10008000);

    // inspect_device_tree(fdt);
    
    probe_pci(0x30000000);

    // if (kernel_verbose) {
    //     sbiret value = sbi_call(SBI_BASE_FN_GET_SPEC_VERSION, 0, 0, 0, 0, 0, 0, SBI_EXT_BASE);
    //     kprintf("get_spec_version: value=0x%x\terror=%d\n", value.value, value.error);

    //     probe_sbi_extension(SBI_EXT_BASE, "Base");
    //     probe_sbi_extension(SBI_EXT_DBCN, "\"DBCN\" Debug Console");
    //     probe_sbi_extension(SBI_EXT_HSM, "\"HSM\" Hart State Management");
    //     probe_sbi_extension(SBI_EXT_SRST, "\"SRST\" System Reset");
    //     probe_sbi_extension(SBI_EXT_TIME, "\"TIME\" Timer");
    // }

    // for (long hid = 0; hid < MAX_HARTS; hid++) {
    //     enum SBI_HSM_STATE status = hart_get_status(hid);
    //     if (status == SBI_HSM_STATE_ERROR) {
    //         num_harts = hid;
    //         break;
    //     }
    //     if (kernel_verbose && hid + 1 == MAX_HARTS)
    //         kprintf("There may be more than %d harts...\n", MAX_HARTS);
    // }
    // kprintf("There are %d harts.\n", num_harts);

    // for (uint32_t start_hart = 0; start_hart < num_harts; start_hart++) {
    //     if (start_hart == hartid)
    //         continue;
    //     kprintf("Going to try starting Hart %d.\n", start_hart);
    //     paddr_t page = alloc_pages(1);
    //     sbi_call(start_hart, (uint32_t)&secondary_boot, (uint32_t)page, 0, 0, 0, SBI_HSM_FN_HART_START, SBI_EXT_HSM);
    // }

    // virtio_blk_init();

    // hart_local *hl = get_hart_local();
    // hl->idle_proc = create_process(NULL, 0);
    // set_current_proc(hl->idle_proc);

    // struct file *file = fs_lookup("shell.bin");
    // process *proc = create_process(file->data, file->size);

    // kprintf("Starting process %d...\n\n", proc->pid);
    // yield();
#endif

    // Shutdown?
    kernel_shutdown(hartid);
}

void handle_syscall(struct trap_frame *f) {
    // kprintf("Handling syscall on core #%d\n", get_hart_local()->hartid);
    switch (f->a3) {
        case SYS_YIELD:
            yield();
            break;
        case SYS_PUTCHAR:
            putchar(f->a0);
            break;
        case SYS_GETCHAR:
            while (1) {
                long ch = getchar();
                if (ch >= 0) {
                    f->a0 = ch;
                    break;
                }

                yield();
            }
            break;
        case SYS_EXIT:
            process *current_proc = get_current_proc();
            kprintf("process %d exited\n", current_proc->pid);
            current_proc->state = PROC_EXITED;
            yield();
            PANIC("unreachable");
        case SYS_READFILE:
        case SYS_WRITEFILE: {
            const char *filename = (const char *) f->a0;
            char *buf = (char *) f->a1;
            int len = f->a2;
            struct file *file = fs_lookup(filename);
            if (!file) {
                kprintf("file not found: %s\n", filename);
                f->a0 = -1;
                break;
            }

            if (len > (int) sizeof(file->data))
                len = file->size;

            if (f->a3 == SYS_WRITEFILE) {
                memcpy(file->data, buf, len);
                file->size = len;
                fs_flush();
            } else {
                memcpy(buf, file->data, len);
            }

            f->a0 = len;
            break;
        }
        default:
            PANIC("unexpected syscall a3=%x\n", f->a3);
    }
}

void handle_trap(struct trap_frame *f) {
    uint32_t scause = READ_CSR(scause);
    uint32_t stval = READ_CSR(stval);
    uint32_t user_pc = READ_CSR(sepc);
    if (scause == SCAUSE_ECALL) {
        handle_syscall(f);
        user_pc += 4;
    } else {
        PANIC("unexpected trap scause=%x, stval=%x, sepc=%x\n", scause, stval, user_pc);
    }

    WRITE_CSR(sepc, user_pc);
}

__attribute__((naked))
void secondary_boot() {
    __asm__ __volatile__ (
        "mv a7, a0"
        : // Output operands
        : // input operands
        : "a7" // clobbers
    );
    __asm__ __volatile__ (
        "mv sp, a1\n"  // Set the stack pointer
        "mv a0, a7\n"
        // "mv a1, a7\n"
        "call secondary_main" // Jump to kernel_main with restored a0 and a1
        : // Output operands
        : // input operands
        : "sp", "a0" // clobbers
    );
}

__attribute__((section(".text.boot")))
__attribute__((naked))
void boot() {
    __asm__ __volatile__ (
        "mv a6, a0\n"
        "mv a7, a1"
        : // Output operands
        : // input operands
        : "a6", "a7" // clobbers
    );
    __asm__ __volatile__ (
        "mv sp, %[stack_top]\n"  // Set the stack pointer
        "mv a0, a6\n"
        "mv a1, a7\n"
        "call kernel_main" // Jump to kernel_main with restored a0 and a1
        : // Output operands
        : [stack_top] "r" (__stack_top) // input operands
        : "sp", "a0", "a1" // clobbers
    );
}
